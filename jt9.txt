JT9 is a mode designed for amateur QSOs and beacon-like transmissions
at MF and LF.  The mode uses the same 72-bit user messages as JT65,
augmented by a 12-bit cyclic redundancy check (CRC).  Error-control
coding uses a convolutional code with constraint length K=16, rate
r=1/2, and a zero tail, leading to an encoded message length of
(72+12+15)*2 = 198 bits.  Modulation is 9-FSK -- 8 tones for data, and
one for a synchronization vector.  With 15 symbol intervals used for
synchronization, a transmission requires a total of 198/3 + 15 = 81
channel symbols.  Tone spacing df of the 9-FSK modulation is equal to
the keying rate; symbol duration tsym = 1/df, and the total occupied
bandwidth is 9*df.  Transmission length is slightly less than the T/R
sequence time, to allow for message decoding at time Tdec, a time 
Tfree seconds before the next transmission starts.

Parameters of the five JT9 sub-modes are summarized in the following
table, along with S/N thresholds measured by simulation on an AWGN
(additive white Gaussian noise) channel.  Parameter nsps1 is the number
of samples per symbol at sample rate 12000 Hz; nsps is the same 
quantity at 750 Hz.

------------------------------------------------------------------------
Mode    nsps1  nsps   df    tsym  BW    S/N*   Tdec  Tfree   Factors 
        12000   750  (Hz)   (s)  (Hz)   (dB)   (s)    (s)    of nsps
------------------------------------------------------------------------
JT9-1    7168   448  1.674  0.60 15.1  -26.9   51.9   8.1   2^10 7
JT9-2   16000  1000  0.750  1.33  6.8  -30.2  111.5   8.5   2^7 5^3
JT9-5   42336  2646  0.283  3.53  2.5  -34.4  289.4  10.6   2^5 3^3 7^2
JT9-10  86400  5400  0.139  7.20  1.3  -37.5  586.7  13.3   2^7 3^3 5^2
JT9-30 262144 16384  0.046 21.85  0.4  -42.3 1773.4  26.6   2^18
------------------------------------------------------------------------
* Noise power measured in a 2500 Hz bandwidth.


Transmitting
------------
1. Source encode the structured message to 72 bits
2. Add 12-bit CRC
3. Convolutionally encode (K=16, r=1/2) to (72+12+15)*2 = 198 bits
4. Interleave to scramble the bit order
5. Assemble 3-bit groups to make 198/3 = 66 symbols
6. Apply Gray code to the symbol values
7. Insert 15 sync symbols ==> 66+15=81 channel symbols with values 0-8


Receiving
---------
1.  Apply noise blanking with the timf2 method
2.  Filter to 500 Hz bandwidth, downsample (1/16) to 750 Hz complex
    using FIR filter with 61 taps.  Data in array c0(1800*750) (1.35M)
3.  Compute symbol-length spectra at half-symbol steps.  Use for
    waterfalls s(16384) and save in ss(180,16384), savg(16384)
4.  At time Tdec, look for sync vectors in ss() to get  estimates of DF, DT
5.  Do full-length FFTs of length NFFT1=96*nsps
6.  For each candidate JT9 signal, do inverse FFT of length 1536.  This 
    gives 16 complex samples per symbol, sync tone should be close to f=0.
7.  Use afc65b method to get improved values of DF, DT.
8.  Tweak freq and time offset to 0.
9.  Compute 8-bin spectra of 66 data symbols: s2(8,66).  Re-order the
    bins by removing Gray code.
10. Compute soft symbols for 198 bits
11. Re-order the bits by removing interleaving.
12. Pack bits into bytes, send to Viterbi decoder ==> 72-bit message, 
    12-bit CRC, and metric.
13. Declare erasure if CRC check fails
14. If CRC is good, remove source encoding and display user message.
